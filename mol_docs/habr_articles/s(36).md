# s
Здравствуйте, меня зовут Дмитрий Карловский и я.. люблю власть. Когда я берусь за клавиатуру, каждый байтик начинает плясать под мою дудку. Но когда этих байтиков становится по настоящему много, уследить за всеми становится сложно. Поэтому давайте сравним популярные паттерны проектирования, позволяющие разделить большое приложение на компоненты, чтобы властвовать над ними максимально эффективно и независимо.

Так как одна и та же прикладная сущность встречается в приложении во многих местах, в разных контекстах, и должна иметь разное представление, то базовая декомпозиция заключается в выделении *модели* предметной области, которая является источником истины для всех мест её *отображения*. И тут начинаются нюансы..

? Обратите внимание, что далее стрелки показывают не движение данных, как их часто рисуют, а наличие знания одного компонента системы, как работать с другим. В пределе это знание выражается в полном контроле жизненного цикла: от создания, до уничтожения. Отсутствие же знания даёт независимость от конкретной реализации, а значит и возможность работать с разными реализациями.

## Model-View

Модель знает как себя по разному представлять.

![MV](https://habrastorage.org/r/w1560/getpro/habr/upload_files/847/7fe/db0/8477fedb0c78aa3560f84637a8d321db.png "MV")

MV

### Пример

```typescript
class User { // Model
	
	_id: bigint
	_nickname: string
	
	toString() { // View
		return 'user=' + this._id
	}
	
	toJSON() { // View
		return {
			id: String( this._id ),
			name: this._nickname,
		}
	}
	
}
```

### Особенности

✅ Удобно из модели получать любые отображения.

❌ Добавление нового отображения требует изменения модели.

❌ Отображение полностью определяется одной основной моделью.

❌ Загрузка модели вытягивает по зависимостям и все её отображения.

❌ Двух слоёв слишком мало на больших масштабах.

## View-Model

Код работы с моделями пишется прямо в отображении.

![VM](https://habrastorage.org/r/w1560/getpro/habr/upload_files/47b/22f/ba1/47b22fba1fa500203943d9a82c8f2f8a.png "VM")

VM

### Пример

```typescript
// View
function Task_list() {
	return <ul>{
		Task.list.map( task =>
			<li><Task_row {task} /></li>
		)
	}</ul>
}

// Model
class Task {
	static list = [] as Task[]
}
```

### Особенности

✅ Отображение может использовать произвольные модели.

✅ Легко добавлять новые отображения, не меняя модели.

❌ Для отображения разных моделей необходимо дублировать код отображения.

❌ Изменение интерфейса модели требует обновления всех использующих её отображений.

❌ Двух слоёв слишком мало на больших масштабах.

## Model-View-ViewModel

Отображения работают с моделями через посредников, которые трансформируют абстракции предметной области в абстракции отображения и обратно. ViewModel также выступает хранилищем состояния отображения, не связанного с предметной областью.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/3ba/798/920/3ba7989200d4cd28edda46d178fdf2a3.png)

MVVM

### Пример

```typescript
// View
<li class="User_card" model="User_card_model">
	<img src={ image } />
	<p>{ message }</p>
</li>

// ViewModel
class User_card_model {
	user = User.current
	get image() {
		return this.user.avatar
	}
	get message() {
		return this.user.nickname
	}
}

// Model
class User {
	avatar: string
	nickname: string
	static current = new User
}
```

### Особенности

✅ Отображение может использовать произвольные вьюмодели.

✅ Легко добавлять новые отображения, не меняя ни модели, ни вьюмодели.

✅ Изменение интерфейса модели или отображения требует изменения только лишь вьюмодели.

✅ Одну и ту же вьюмодель можно шарить между несколькими отображениями.

❌ Для отображения разных моделей необходимо дублировать код отображения и вьюмодели.

❌ Трёх слоёв слишком мало на больших масштабах.

## Model-View-Controller

Контроллер создаёт отображение, и говорит ему с какой моделью работать. Так же он обрабатывает все команды от пользователя, и управляет своими подопечными.

![MVC](https://habrastorage.org/r/w1560/getpro/habr/upload_files/4b5/5cf/78f/4b55cf78f7851600f42853df1e9e904b.png "MVC")

MVC

### Пример

```typescript
// Controller
class Users_resource {
	GET() {
		return User.all.map( user_brief )
	}
}

// View
function user_brief( user: User ) {
	return {
		id: user.guid,
		name: user.passport.name_full,
	}
}

// Model
class User {
	
	static all = [] as User[]
	
	guid: GUID
	passports: Passport[]
	resumes: Resume[]
	
	get passport() {
		return this.passports[0]
	}
	
}
```

## Особенности

✅ Отображение может использовать произвольные модели с тем же интерфейсом.

✅ Легко добавлять новые отображения, не меняя модели. И наоборот.

❌ Для отображения разных типов моделей необходимо дублировать код отображения.

❌ Изменение интерфейса модели требует обновления всех использующих её отображений и контроллеров.

❌ Трёх слоёв слишком мало на больших масштабах.

## Model-View-Presenter

Модели и отображения пассивны, и не знают друг о друге - они управляются презентером, который выступает и в качестве посредника между ними.

![MVP](https://habrastorage.org/r/w1560/getpro/habr/upload_files/811/21c/831/81121c83108b00daed1245ad9b85163a.png "MVP")

MVP

### Пример

```typescript
// Presenter
class User_preview {
	user: User
	card = new Card({
		image: ()=> this.user.avatar,
		message: ()=> this.user.nickname,
		color: ()=> this.user.skin.color,
		click: ()=> this.skin_change(),
	})
	skin_change() {
		this.user.skin = Skin.random()
	}
}

// View
<div class="Card" onclick={click} style={{ background: color }}>
	<img src={ image } />
	<p>{ message }</p>
</div>

// Model
class User extends Model {
	avatar: string
	nickname: string
	skin: Skin
}
```

## Особенности

✅ Легко добавлять новые отображения, не меняя модели. И наоборот.

✅ Изменение интерфесов модели или отображения требует изменения только лишь презентеров.

❌ Трёх слоёв слишком мало на больших масштабах.

❌ Для использования состояния одного презентера из другого необходимо искусственное вынесение его в модели.

## ModelView Fractal

Каждый ModelView выступает в роли модели/контроллера для ведомых ModelView и в качестве отображения для владеющего ModelView. Часть логики может выноситься как в чистые Model, так и в чистые View, которые являются лишь вырожденными случаями ModelView.

![MVF](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d64/bea/2b2/d64bea2b24be2ce197ef7d69e9ba7253.png "MVF")

MVF

### Пример

```ruby
$my_user_list $my_view
	- \Owner ModelView
	users? /$my_user
	kids /
		<= Row*0 $my_user_row
			user <= user* $my_user

$my_user_row $my_card
	- \Having ModevView
	user $my_user
		avatar => image
		nickname => message

$my_card $my_view
	- \View not Model
	kids /
		<= Image $my_image
			uri <= image \about:blank
		<= Message $my_text
			text <= message \
	
$my_user $my_model
	- \Model not View
	avatar? \
	nickname? \
```

### Особенности

✅ Каждый ModelView полностью контролирует внутренние ModelView и ничего не знает про внешние.

✅ Любой ModelView может шариться между разными другими ModelView на любом уровне композиции.

✅ Изменение интерфейса ModelView требует изменения только лишь его владельцев.

✅ Фрактальная структура легко масштабируется на приложения любого размера.

## Выводы

[$mol\_view](https://mol.hyoo.ru/#!section=docs/=vv2nig_s5zr0f) построен на идеях MVF, так как это наиболее простой паттерн декомпозиции, который легко масштабируется по мере потребности и хорошо разделяет разные уровни абстракции.

## Ссылочки

[Другие анализы](https://mol.hyoo.ru/#!section=docs/=ggj5i7_4ou8ny)   
 [Следите за новостями](https://t.me/mol_news)   
 [Обсуждайте наболевшее](https://t.me/h_y_o_o/28)   
 [Донатьте на печеньки](https://boosty.to/hyoo)

---

[Актуальный оригинал на $hyoo\_page.](https://mol.hyoo.ru/#!section=docs/=go30rj_7vr107)

Только зарегистрированные пользователи могут участвовать в опросе. [Войдите](/kek/v1/auth/habrahabr/?back=/ru/articles/804193/&hl=ru), пожалуйста.

Какой паттерн лежит в основе вашей архитектуры?

0% MV0

6.25% VM3

35.42% MVVM17

29.17% MVC14

10.42% MVP5

8.33% MVF4

10.42% Другой, нарисую в комментах5

Проголосовали 48 пользователей. Воздержались 20 пользователей.