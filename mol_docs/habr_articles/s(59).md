# s
Здравствуйте, меня зовут Дмитрий Карловский и раньше я… ежедневно измерял [свою пипирку](https://habr.com/ru/users/nin-jin/), но у распространённых линеек никак не хватало точности для измерения столь малых размеров.

  

![](https://habrastorage.org/r/w1560/getpro/habr/post_images/b4b/189/577/b4b189577476b717cddaf4e9cad5490c.png)

  

Поэтому я решил, что хватит это терпеть!… и выстругал свою с нанометровыми делениями, поддержкой прохладного и разгорячённого измерения, тестами, шарингом и прочими вольностями. Так что приглашаю и вас присоединиться к этой спец олимпиаде по измерению скорости своего JS кода.

  

Для начала разберём этот кейс:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/08c/e99/525/08ce995255d7eefe8200f9d634674ce2.png)](https://tinyurl.com/y9dgcz4c)

  

# Наследственный кейс

  

Тут у нас 3 варианта исполнения:

  

* **мономорфный** — это когда одной и той же функции на вход каждый раз передаются одни и те же типы аргументов. JIT создаёт оптимизированный код, в начале которого идёт лишь проверка, что тип передан тот же.
* **полиморфный** — это когда одной и той же функции на вход передаются разные типы аргументов, но их вариативность незначительна (до 4 в Chrome 88, и до 7 в Firefox 85). Тут JIT создаёт несколько версий оптимизированного кода и переключается между ними в зависимости от типов аргументов.
* **мегаморфный** — это когда одной и той же функции на вход передаются разные типы аргументов с большой вариативностью. JIT в этом случае сдаётся и выпиливает свои бесполезные оптимизации напрочь.

  

JIT за свои оптимизации берётся не сразу, а только после некоторого числа запусков одной и той же функции. Поэтому если ваш код исполняется лишь единожды, то ни на какие оптимизации вы можете не рассчитывать. Но если он исполняется много раз, то такой код может быть довольно быстрым. Если, конечно, вы не сломаете оптимизации, например, мегаморфностью.

  

Так что при измерении скорости кода важно знать и время прохладного запуска (голубая пипирка), и время разгорячённого (оранжевая пипирка), чтобы хорошо понимать на какую скорость вы можете рассчитывать в зависимости от частоты его использования.

  

Мегаморфность может появиться у вас совершенно случайно. Например, вы создали класс с 10 полями и геттером, их суммирующим:

  

```javascript
class Base {

    p0 = 0
    p1 = 1
    p2 = 2
    p3 = 3
    p4 = 4
    p5 = 5
    p6 = 6
    p7 = 7
    p8 = 8
    p9 = 9

    get s() {
        return (
            + this.p0
            + this.p1
            + this.p2
            + this.p3
            + this.p4
            + this.p5
            + this.p6
            + this.p7
            + this.p8
            + this.p9
        )
    }

}
```

  

Теперь добавим пяток наследников:

  

```javascript
const Derived = [
    class extends Base { n0 = 0 },
    class extends Base { n1 = 1 },
    class extends Base { n2 = 2 },
    class extends Base { n3 = 3 },
    class extends Base { n4 = 4 },
]
```

  

И создадим 3 массива с разной степенью вариативности типов элементов:

  

```javascript
const mono = Array.from( {length}, ()=> new Derived[0] )
const poly = Array.from( {length}, (_,i)=> new Derived[i%4] )
const mega = Array.from( {length}, (_,i)=> new Derived[i%5] )
```

  

При прогоне редьюсера по первому массиву, у нас всё хорошо — JIT оптимизировал его по самое неболуйся, заинлайнив всё, что возможно. При прогоне по второму массиву из-за полиморфности производительность как прохладного, так и разгорячённого кода падает в 2 раза. А на третьем массиве все оптимизации теряются и разгорячённый код исполняется почти с той же скоростью, что и прохладный.

  

Отдельно стоит разобрать повторный запуск редьюсера на первом массиве — его максимальная производительность немного просела. Дело тут в том, что не смотря на то, что хоть сам код редьюсера и мономорфный, суммирующий геттер остаётся мегаморфным, ведь он уже запускался на экземплярах разных классов и JIT выпилил его оптимизацию.

  

И единственный способ это побороть — это создавать по отдельной функции для каждого наследника. Тогда каждый из них будет мономорфным и JIT будет оптимизировать их независимо. Это даст высокую производительность после прогрева, но ценой огромного потребления памяти.

  

На всякий случай, уточню, что при создании множества замыканий одним и тем же кодом, нативная функция будет создана только одна. А в каждое замыкание движок помещает лишь ссылку на эту функцию и ссылку на текущий контекст её исполнения.

  

# Полевой кейс

  

Есть и ещё менее очевидные способы всё испортить. Например, воспользоваться инициализаторами полей класса:

  

```javascript
class A {
    p0 = 0
    p1 = 0
    p2 = 0
    p3 = 0
    p4 = 0
    p5 = 0
    p6 = 0
    p7 = 0
    p8 = 0
    p9 = 0
}

class B {
    constructor() {
        this.p0 = 0
        this.p1 = 0
        this.p2 = 0
        this.p3 = 0
        this.p4 = 0
        this.p5 = 0
        this.p6 = 0
        this.p7 = 0
        this.p8 = 0
        this.p9 = 0
    }
}

function C() {
    this.p0 = 0
    this.p1 = 0
    this.p2 = 0
    this.p3 = 0
    this.p4 = 0
    this.p5 = 0
    this.p6 = 0
    this.p7 = 0
    this.p8 = 0
    this.p9 = 0
}
```

  

Chrome 88 выдаёт следующую картину:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/d0a/4be/d07/d0a4bed0750c337798950c0738680fc9.png)](https://perf.js.hyoo.ru/#prefix=let%20res/sources=%5B%22res%20%3D%20new%20A%22%2C%22res%20%3D%20new%20B%22%2C%22res%20%3D%20new%20C%22%5D/prefixes=%5B%22class%20A%20%7B%5Cn%20%20%20%20p0%20%3D%200%5Cn%20%20%20%20p1%20%3D%200%5Cn%20%20%20%20p2%20%3D%200%5Cn%20%20%20%20p3%20%3D%200%5Cn%20%20%20%20p4%20%3D%200%5Cn%20%20%20%20p5%20%3D%200%5Cn%20%20%20%20p6%20%3D%200%5Cn%20%20%20%20p7%20%3D%200%5Cn%20%20%20%20p8%20%3D%200%5Cn%20%20%20%20p9%20%3D%200%5Cn%7D%22%2C%22class%20B%20%7B%5Cn%20%20%20%20constructor%28%29%20%7B%5Cn%20%20%20%20%20%20%20%20this.p0%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p1%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p2%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p3%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p4%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p5%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p6%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p7%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p8%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p9%20%3D%200%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22function%20C%28%29%20%7B%5Cn%20%20%20%20this.p0%20%3D%200%5Cn%20%20%20%20this.p1%20%3D%200%5Cn%20%20%20%20this.p2%20%3D%200%5Cn%20%20%20%20this.p3%20%3D%200%5Cn%20%20%20%20this.p4%20%3D%200%5Cn%20%20%20%20this.p5%20%3D%200%5Cn%20%20%20%20this.p6%20%3D%200%5Cn%20%20%20%20this.p7%20%3D%200%5Cn%20%20%20%20this.p8%20%3D%200%5Cn%20%20%20%20this.p9%20%3D%200%5Cn%7D%22%5D)

  

Видимо эту фичу прикручивали в V8 противники преждевременной оптимизации, которые всё ещё ждут подходящего багрепорта, чтобы героически ускорить создание классов в 10 раз. А вот над Firefox 85 работают сторонники своевременной оптимизации:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/fb5/429/aad/fb5429aadd44bbd17fc7de3e186c3745.png)](https://perf.js.hyoo.ru/#prefix=let%20res/sources=%5B%22res%20%3D%20new%20A%22%2C%22res%20%3D%20new%20B%22%2C%22res%20%3D%20new%20C%22%5D/prefixes=%5B%22class%20A%20%7B%5Cn%20%20%20%20p0%20%3D%200%5Cn%20%20%20%20p1%20%3D%200%5Cn%20%20%20%20p2%20%3D%200%5Cn%20%20%20%20p3%20%3D%200%5Cn%20%20%20%20p4%20%3D%200%5Cn%20%20%20%20p5%20%3D%200%5Cn%20%20%20%20p6%20%3D%200%5Cn%20%20%20%20p7%20%3D%200%5Cn%20%20%20%20p8%20%3D%200%5Cn%20%20%20%20p9%20%3D%200%5Cn%7D%22%2C%22class%20B%20%7B%5Cn%20%20%20%20constructor%28%29%20%7B%5Cn%20%20%20%20%20%20%20%20this.p0%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p1%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p2%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p3%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p4%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p5%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p6%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p7%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p8%20%3D%200%5Cn%20%20%20%20%20%20%20%20this.p9%20%3D%200%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22function%20C%28%29%20%7B%5Cn%20%20%20%20this.p0%20%3D%200%5Cn%20%20%20%20this.p1%20%3D%200%5Cn%20%20%20%20this.p2%20%3D%200%5Cn%20%20%20%20this.p3%20%3D%200%5Cn%20%20%20%20this.p4%20%3D%200%5Cn%20%20%20%20this.p5%20%3D%200%5Cn%20%20%20%20this.p6%20%3D%200%5Cn%20%20%20%20this.p7%20%3D%200%5Cn%20%20%20%20this.p8%20%3D%200%5Cn%20%20%20%20this.p9%20%3D%200%5Cn%7D%22%5D)

  

С другой стороны, как видно из графиков, V8 умеет оптимизировать создание объектов сразу при прохладном старте, а вот Firefox дожидается разгорячённого, но делает это чуть-чуть получше.

  

# Фабричный кейс

  

И раз уж мы заговорили про создание объектов, то это тоже можно делать сильно по разному. Например, в [$mol](https://mol.hyoo.ru/) у нас стояла такая задача: необходимо при старте приложения создавать большое число объектов, при этом у каждого объекта есть несколько десятков методов, часть из которых может быть переопределена при создании. У меня получилось 3 варианта с разной производительностью..

  

Принимать в универсальном конструкторе словарь с переопределениями методов:

  

```javascript
class Dictionary_base {
    constructor( dict ) {
        Object.assign( this , dict )
    }
}
```

  

Принимать функцию инициализации вместо словаря:

  

```javascript
class Initializer_base {
    constructor( init ) {
        if( init ) init( this )
    }
}
```

  

Ну или попросту оставить конструктор пустым, а переопределения задавать сразу после создания объекта.

  

Результаты в Chrome 88 несколько противоречивы:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/4ed/be3/c7a/4edbe3c7a9ad8b619b06bfd95b5a289e.png)](https://perf.js.hyoo.ru/#prefix=let%20res/sources=%5B%22res%20%3D%20new%20Dictionary%28%7B%5Cn%5Cttitle%3A%20%28%29%3D%3E%20'xxx'%2C%5Cn%5Ctid%3A%20%28%29%3D%3E%20%7B%23%7D%2C%5Cn%5Ctres%3A%20%28%29%3D%3E%20res%2C%5Cn%7D%29%22%2C%22res%20%3D%20new%20Initializer%28%20foo%20%3D%3E%20%7B%5Cn%5Ctfoo.title%20%3D%20%28%29%3D%3E%20'xxx'%5Cn%5Ctfoo.id%20%3D%20%28%29%3D%3E%20%7B%23%7D%2C%5Cn%5Ctfoo.res%20%3D%20%28%29%3D%3E%20res%5Cn%7D%20%29%22%2C%22var%20foo%20%3D%20new%20Empty%5Cnfoo.title%20%3D%20%28%29%3D%3E%20'xxx'%5Cnfoo.id%20%3D%20%28%29%3D%3E%20%7B%23%7D%2C%5Cnfoo.res%20%3D%20%28%29%3D%3E%20res%5Cnres%20%3D%20foo%22%5D/optimized=true/postfix/prefixes=%5B%22class%20Dictionary_base%20%7B%5Cn%5Ctconstructor%28%20dict%20%29%20%7B%5Cn%5Ct%5CtObject.assign%28%20this%20%2C%20dict%20%29%5Cn%5Ct%7D%5Cn%7D%5Cnclass%20Dictionary%20extends%20Dictionary_base%20%7B%5Cn%5Cttitle%28%29%20%7B%20return%20'title'%20%7D%5Cn%5Ctid%28%29%20%7B%20return%200%20%7D%5Cn%5Ctres%28%29%20%7B%20return%20null%20%7D%5Cn%7D%22%2C%22class%20Initializer_base%20%7B%5Cn%5Ctconstructor%28%20init%20%29%20%7B%5Cn%5Ct%5Ctif%28%20init%20%29%20init%28%20this%20%29%5Cn%5Ct%7D%5Cn%7D%5Cnclass%20Initializer%20extends%20Initializer_base%20%7B%5Cn%5Cttitle%28%29%20%7B%20return%20'title'%20%7D%5Cn%5Ctid%28%29%20%7B%20return%200%20%7D%5Cn%5Ctres%28%29%20%7B%20return%20null%20%7D%5Cn%7D%22%2C%22class%20Empty_base%20%7B%20%7D%5Cnclass%20Empty%20extends%20Empty_base%20%7B%5Cn%5Cttitle%28%29%20%7B%20return%20'title'%20%7D%5Cn%5Ctid%28%29%20%7B%20return%200%20%7D%5Cn%5Ctres%28%29%20%7B%20return%20null%20%7D%5Cn%7D%22%5D)

  

Словарь хуже оптимизируется, зато даже прохладный он работает довольно быстро. А вот в Firefox 85 ситуация существенно иная:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/a1c/bd0/624/a1cbd0624ad76534e269d63273cd93ef.png)](https://perf.js.hyoo.ru/#prefix=let%20res/sources=%5B%22res%20%3D%20new%20Dictionary%28%7B%5Cn%5Cttitle%3A%20%28%29%3D%3E%20'xxx'%2C%5Cn%5Ctid%3A%20%28%29%3D%3E%20%7B%23%7D%2C%5Cn%5Ctres%3A%20%28%29%3D%3E%20res%2C%5Cn%7D%29%22%2C%22res%20%3D%20new%20Initializer%28%20foo%20%3D%3E%20%7B%5Cn%5Ctfoo.title%20%3D%20%28%29%3D%3E%20'xxx'%5Cn%5Ctfoo.id%20%3D%20%28%29%3D%3E%20%7B%23%7D%2C%5Cn%5Ctfoo.res%20%3D%20%28%29%3D%3E%20res%5Cn%7D%20%29%22%2C%22var%20foo%20%3D%20new%20Empty%5Cnfoo.title%20%3D%20%28%29%3D%3E%20'xxx'%5Cnfoo.id%20%3D%20%28%29%3D%3E%20%7B%23%7D%2C%5Cnfoo.res%20%3D%20%28%29%3D%3E%20res%5Cnres%20%3D%20foo%22%5D/optimized=true/postfix/prefixes=%5B%22class%20Dictionary_base%20%7B%5Cn%5Ctconstructor%28%20dict%20%29%20%7B%5Cn%5Ct%5CtObject.assign%28%20this%20%2C%20dict%20%29%5Cn%5Ct%7D%5Cn%7D%5Cnclass%20Dictionary%20extends%20Dictionary_base%20%7B%5Cn%5Cttitle%28%29%20%7B%20return%20'title'%20%7D%5Cn%5Ctid%28%29%20%7B%20return%200%20%7D%5Cn%5Ctres%28%29%20%7B%20return%20null%20%7D%5Cn%7D%22%2C%22class%20Initializer_base%20%7B%5Cn%5Ctconstructor%28%20init%20%29%20%7B%5Cn%5Ct%5Ctif%28%20init%20%29%20init%28%20this%20%29%5Cn%5Ct%7D%5Cn%7D%5Cnclass%20Initializer%20extends%20Initializer_base%20%7B%5Cn%5Cttitle%28%29%20%7B%20return%20'title'%20%7D%5Cn%5Ctid%28%29%20%7B%20return%200%20%7D%5Cn%5Ctres%28%29%20%7B%20return%20null%20%7D%5Cn%7D%22%2C%22class%20Empty_base%20%7B%20%7D%5Cnclass%20Empty%20extends%20Empty_base%20%7B%5Cn%5Cttitle%28%29%20%7B%20return%20'title'%20%7D%5Cn%5Ctid%28%29%20%7B%20return%200%20%7D%5Cn%5Ctres%28%29%20%7B%20return%20null%20%7D%5Cn%7D%22%5D)

  

Последний вариант тут оказывается самым быстрым при любом варианте исполнения. А так как Chrome в любом варианте оказывается быстрее, чем Firefox в самом быстром, то ориентироваться лучше именно на Firefox, чтобы показывать приемлемую производительность даже в худшем для нас случае. Поэтому мы остановились на варианте c [переопределениями после создания экземпляра](https://mol.hyoo.ru/#section=view.tree/source=%24my_app%20%24mol_book2%0A%09Placeholder%20%24mol_page%0A%09%09title%20%5CHello%0A).

  

# Солидный кейс

  

Возможно вас смутила копипаста в некоторых примерах. Ведь её же можно заменить на цикл с добавлением свойств. Однако, при пипиркомерстве важно знать, что цикл вовсе не эквивалентен копипасте. Порой он выходит быстрее за счёт оптимизаций. А порой — драматически медленнее. Создадим, для примера, два одинаковых объекта. Первый наполним полями итеративно:

  

```javascript
const chain = {}
const uid = ()=> Math.random().toString(16).slice(2)

for( let i = 0; i < 100; i++ ){
    chain[ uid() ] = i
}
```

  

А второй создадим сразу с нужными полями. Чтобы не копипастить, воспользуемся хаком:

  

```javascript
const solid = JSON.parse( JSON.stringify( chain ) )
```

  

Ну, и для полной картины, добавим ещё и словарик:

  

```javascript
const map = new Map
for( let key in chain ) map.set( key, chain[key] )
```

  

В Chrome 88 мы видим просто реактивную работу цельносозданного объекта.

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/bcd/f58/3f6/bcdf583f636e2a2f53970e64342caed6.png)](https://perf.js.hyoo.ru/#prefix=const%20chain%20%3D%20%7B%7D%0Aconst%20uid%20%3D%20%28%29%3D%3E%20Math.random%28%29.toString%2816%29.slice%282%29%0A%0Afor%28%20let%20i%20%3D%200%3B%20i%20%3C%20100%3B%20i%2B%2B%20%29%7B%0A%09chain%5B%20uid%28%29%20%5D%20%3D%20i%0A%7D%0A%0Aconst%20solid%20%3D%20JSON.parse%28%20JSON.stringify%28%20chain%20%29%20%29%0A%0Aconst%20map%20%3D%20new%20Map%0Afor%28%20let%20key%20in%20chain%20%29%20map.set%28%20key%2C%20chain%5Bkey%5D%20%29%0A%0Alet%20res/sources=%5B%22res%20%3D%20Object.keys%28%20chain%20%29%22%2C%22res%20%3D%20Object.keys%28%20solid%20%29%22%2C%22res%20%3D%20%5B%20...%20map.keys%28%29%20%5D%22%5D/postfix=%24mol_assert_equal%28%20Object.keys%28%20chain%20%29.length%2C%20100%20%29%0A%24mol_assert_equal%28%20Object.keys%28%20solid%20%29.length%2C%20100%20%29%0A%24mol_assert_equal%28%20map.size%2C%20100%20%29%0A%0Aconst%20first%20%3D%20Object.keys%28%20chain%20%29%5B0%5D%0A%24mol_assert_equal%28%20chain%5Bfirst%5D%2C%20solid%5Bfirst%5D%2C%20map.get%28first%29%20%29)

  

Видимо цепочка скрытых классов, которая в этом случае не создаётся, — довольно дорогое удовольствие. А вот в Firefox 85 это не так — тут всё одинаково медленно:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/c85/27c/bee/c8527cbee45796b5dedc23b4bb63ea22.png)](https://perf.js.hyoo.ru/#prefix=const%20chain%20%3D%20%7B%7D%0Aconst%20uid%20%3D%20%28%29%3D%3E%20Math.random%28%29.toString%2816%29.slice%282%29%0A%0Afor%28%20let%20i%20%3D%200%3B%20i%20%3C%20100%3B%20i%2B%2B%20%29%7B%0A%09chain%5B%20uid%28%29%20%5D%20%3D%20i%0A%7D%0A%0Aconst%20solid%20%3D%20JSON.parse%28%20JSON.stringify%28%20chain%20%29%20%29%0A%0Aconst%20map%20%3D%20new%20Map%0Afor%28%20let%20key%20in%20chain%20%29%20map.set%28%20key%2C%20chain%5Bkey%5D%20%29%0A%0Alet%20res/sources=%5B%22res%20%3D%20Object.keys%28%20chain%20%29%22%2C%22res%20%3D%20Object.keys%28%20solid%20%29%22%2C%22res%20%3D%20%5B%20...%20map.keys%28%29%20%5D%22%5D/postfix=%24mol_assert_equal%28%20Object.keys%28%20chain%20%29.length%2C%20100%20%29%0A%24mol_assert_equal%28%20Object.keys%28%20solid%20%29.length%2C%20100%20%29%0A%24mol_assert_equal%28%20map.size%2C%20100%20%29%0A%0Aconst%20first%20%3D%20Object.keys%28%20chain%20%29%5B0%5D%0A%24mol_assert_equal%28%20chain%5Bfirst%5D%2C%20solid%5Bfirst%5D%2C%20map.get%28first%29%20%29)

  

# Асинхронный кейс

  

Наконец, давайте замерим, насколько асинхронный код медленнее синхронного, на примере рекурсивной версии функции Фибоначчи:

  

```javascript
function fib_sync(n) {
    if( n < 2 ) return 1
    return fib_sync( n - 1 ) + fib_sync( n - 2 )
}

function* fib_gen(n) {
    if( n < 2 ) return 1
    return ( yield* fib_gen( n - 1 ) ) + ( yield* fib_gen( n - 2 ) )
}

async function fib_async(n) {
    if( n < 2 ) return 1
    return ( await fib_async( n - 1 ) ) + ( await fib_async( n - 2 ) )
}
```

  

В Chrome 88 выглядит это примерно так:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/528/f78/c86/528f78c86f9bd98b8d267c9d2076aeec.png)](https://perf.js.hyoo.ru/#prefix=let%20res/sources=%5B%22res%20%3D%20fib_sync%285%29%22%2C%22res%20%3D%20fib_gen%285%29.next%28%29.value%22%2C%22res%20%3D%20fib_async%285%29%5Cn%22%5D/postfix/prefixes=%5B%22function%20fib_sync%28n%29%20%7B%5Cn%5Ctif%28%20n%20%3C%202%20%29%20return%201%5Cn%5Ctreturn%20fib_sync%28%20n%20-%201%20%29%20%2B%20fib_sync%28%20n%20-%202%20%29%5Cn%7D%22%2C%22function*%20fib_gen%28n%29%20%7B%5Cn%5Ctif%28%20n%20%3C%202%20%29%20return%201%5Cn%5Ctreturn%20%28%20yield*%20fib_gen%28%20n%20-%201%20%29%20%29%20%2B%20%28%20yield*%20fib_gen%28%20n%20-%202%20%29%20%29%5Cn%7D%22%2C%22async%20function%20fib_async%28n%29%20%7B%5Cn%5Ctif%28%20n%20%3C%202%20%29%20return%201%5Cn%5Ctreturn%20%28%20await%20fib_async%28%20n%20-%201%20%29%20%29%20%2B%20%28%20await%20fib_async%28%20n%20-%202%20%29%20%29%5Cn%7D%5Cn%22%5D)

  

Да, так любимый всеми асинхронный код — это крайне медленно. И пусть вас не обольщают относительно хорошие показатели разгорячённого асинхронного варианта, ибо моя пипиркомерка замеряет лишь синхронную часть асинхронного вызова. Но большая часть работы идёт асинхронно, уже после того, как замер завершён. Firefox 85 же вообще после замера подвисает на десятки минут и выедает всю память.

  

# Натуральный кейс

  

Ну да ладно, всё это была неэкологичная синтетика. Давайте погоняем что-то натуральное. Например, библиотеки для работы с датами и временем. Возьмём наиболее популярные из них:

  

* [$mol\_time](https://mol.hyoo.ru/#section=articles/search/author=nin-jin/repo=HabHub/article=28)
* [Moment.js](https://momentjs.com/)
* [Luxon](https://moment.github.io/luxon/)
* [Day.js](https://day.js.org/)
* [js-joda](https://js-joda.github.io/js-joda/)
* [date-fns](https://date-fns.org/)

  

И поехали измерять. Начнём с базовой задачи — парсинг строки в формате ISO8601:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/61c/b5a/0d5/61cb5a0d5881ef56c997e7a47785574c.png)](https://perf.js.hyoo.ru/#prefix=const%20iso%20%3D%20'2015-07-20T07%3A48%3A28.338Z'%0A%0Alet%20res/sources=%5B%22res%20%3D%20new%20Date%28%20iso%20%29%22%2C%22res%20%3D%20new%20%24mol_time_moment%28%20iso%20%29%22%2C%22res%20%3D%20moment%28%20iso%20%29%22%2C%22res%20%3D%20luxon.DateTime.fromISO%28%20iso%20%29%22%2C%22res%20%3D%20dayjs%28%20iso%20%29%22%2C%22res%20%3D%20JSJoda.ZonedDateTime.parse%28iso%29%22%2C%22res%20%3D%20dateFns.parse%28%20iso%20%29%22%5D/postfix/prefixes=%5Bnull%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fmol_time_all%401.1.12%2Fweb.js'%5Cn%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Fcdnjs.cloudflare.com%2Fajax%2Flibs%2Fmoment.js%2F2.26.0%2Fmoment.min.js'%5Cn%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fluxon%401.24.1%2Fbuild%2Fglobal%2Fluxon.min.js'%5Cn%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fdayjs%401.8.21%2Fdayjs.min.js'%5Cn%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2F%40js-joda%2Fcore%401.11.0%2Fdist%2Fjs-joda.js'%5Cn%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Fcdnjs.cloudflare.com%2Fajax%2Flibs%2Fdate-fns%2F1.30.1%2Fdate_fns.min.js'%5Cn%29%22%5D)

  

Логично, что нативное API быстрее всех, потом идёт dayjs, который является обёрткой над нативным API, и мой велосипед, который уже не является обёрткой и парсит самостоятельно. Потом dateFns, который хоть и возвращает нативный Date, но парсит его зачем-то самостоятельно и, как видим, довольно медленно. Ну и в конце все остальные лузеры.

  

Штош, замерим и обратную операцию — сериализацию в ISO8601:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/9ee/fc6/5d5/9eefc65d5c25c64bb995eaaa189b6d3f.png)](https://perf.js.hyoo.ru/#prefix=const%20iso%20%3D%20'2015-07-20T07%3A48%3A28.338Z'%0A%0Alet%20res/sources=%5B%22res%20%3D%20iDate.toISOString%28%29%22%2C%22res%20%3D%20iMol.toString%28%29%22%2C%22res%20%3D%20iMoment.toISOString%28%29%22%2C%22res%20%3D%20iLuxon.toUTC%28%29.toISO%28%29%22%2C%22res%20%3D%20iDayJS.toISOString%28%29%22%2C%22res%20%3D%20iJSJoda.toString%28%29%22%5D/postfix=%24mol_assert_equal%28%0A%09res.replace%28%20%2FZ%24%2F%2C%20'%2B00%3A00'%20%29%2C%0A%09'2015-07-20T07%3A48%3A28.338%2B00%3A00'%2C%0A%29/prefixes=%5B%22const%20iDate%20%3D%20new%20Date%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fmol_time_all%401.1.10%2Fweb.js'%5Cn%29%5Cnconst%20iMol%20%3D%20new%20%24mol_time_moment%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Fcdnjs.cloudflare.com%2Fajax%2Flibs%2Fmoment.js%2F2.26.0%2Fmoment.min.js'%5Cn%29%5Cnconst%20iMoment%20%3D%20moment%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fluxon%401.24.1%2Fbuild%2Fglobal%2Fluxon.min.js'%5Cn%29%5Cnconst%20iLuxon%20%3D%20luxon.DateTime.fromISO%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fdayjs%401.8.21%2Fdayjs.min.js'%5Cn%29%5Cnconst%20iDayJS%20%3D%20dayjs%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2F%40js-joda%2Fcore%401.11.0%2Fdist%2Fjs-joda.js'%5Cn%29%5Cnconst%20iJSJoda%20%3D%20JSJoda.ZonedDateTime.parse%28%20iso%20%29%22%5D)

  

Примечательно, что сериализатор JSJoda оказался тут сильно быстрее всех. А вот `dateFns` тут нет, так как она работает с экземплярами нативного Date, а его мы померили самым первым.

  

Для пользователя, однако, обычно используется не ISO8601 представление, а более удобное для человека. Так что замерим и кастомное форматирование:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/541/dc1/123/541dc1123af7bc60dd319f5d835fbdd4.png)](https://perf.js.hyoo.ru/#prefix=const%20iso%20%3D%20'2015-07-20T07%3A48%3A28.338Z'%0A%0Alet%20res/sources=%5B%22res%20%3D%20iMol.toString%28'DD.MM.YYYY'%29%22%2C%22res%20%3D%20iMoment.format%28'DD.MM.YYYY'%29%22%2C%22res%20%3D%20iLuxon.toUTC%28%29%5Cn.toFormat%28'dd.MM.yyyy'%29%22%2C%22res%20%3D%20iDayJS.format%28'DD.MM.YYYY'%29%22%2C%22res%20%3D%20iJSJoda.format%28pattern%29%22%5D/postfix=%24mol_assert_equal%28%20res%2C%20'20.07.2015'%20%29/prefixes=%5B%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fmol_time_all%401.1.12%2Fweb.js'%5Cn%29%5Cnconst%20iMol%20%3D%20new%20%24mol_time_moment%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Fcdnjs.cloudflare.com%2Fajax%2Flibs%2Fmoment.js%2F2.26.0%2Fmoment.min.js'%5Cn%29%5Cnconst%20iMoment%20%3D%20moment%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fluxon%401.24.1%2Fbuild%2Fglobal%2Fluxon.min.js'%5Cn%29%5Cnconst%20iLuxon%20%3D%20luxon.DateTime.fromISO%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fdayjs%401.8.21%2Fdayjs.min.js'%5Cn%29%5Cnconst%20iDayJS%20%3D%20dayjs%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2F%40js-joda%2Fcore%401.11.0%2Fdist%2Fjs-joda.js'%5Cn%29%5Cnconst%20pattern%20%3D%20JSJoda.DateTimeFormatter.ofPattern%28'dd.MM.yyyy'%29%5Cnconst%20iJSJoda%20%3D%20JSJoda.ZonedDateTime.parse%28%20iso%20%29%22%5D)

  

Тут уже отрыв JSJoda не такой существенный. Всё дело в том, что производительность $mol\_time сильнее деградирует по мере усложнения паттерна форматирования. Так что его ещё есть куда улучшать.

  

А в Firefox 85 JSJoda и вовсе сливает:

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/c08/1f8/911/c081f89118af1292b87892d93b3ae5fd.png)](https://perf.js.hyoo.ru/#prefix=const%20iso%20%3D%20'2015-07-20T07%3A48%3A28.338Z'%0A%0Alet%20res/sources=%5B%22res%20%3D%20iMol.toString%28'DD.MM.YYYY'%29%22%2C%22res%20%3D%20iMoment.format%28'DD.MM.YYYY'%29%22%2C%22res%20%3D%20iLuxon.toUTC%28%29%5Cn.toFormat%28'dd.MM.yyyy'%29%22%2C%22res%20%3D%20iDayJS.format%28'DD.MM.YYYY'%29%22%2C%22res%20%3D%20iJSJoda.format%28pattern%29%22%5D/postfix=%24mol_assert_equal%28%20res%2C%20'20.07.2015'%20%29/prefixes=%5B%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fmol_time_all%401.1.12%2Fweb.js'%5Cn%29%5Cnconst%20iMol%20%3D%20new%20%24mol_time_moment%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Fcdnjs.cloudflare.com%2Fajax%2Flibs%2Fmoment.js%2F2.26.0%2Fmoment.min.js'%5Cn%29%5Cnconst%20iMoment%20%3D%20moment%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fluxon%401.24.1%2Fbuild%2Fglobal%2Fluxon.min.js'%5Cn%29%5Cnconst%20iLuxon%20%3D%20luxon.DateTime.fromISO%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Funpkg.com%2Fdayjs%401.8.21%2Fdayjs.min.js'%5Cn%29%5Cnconst%20iDayJS%20%3D%20dayjs%28%20iso%20%29%22%2C%22%24mol_import.script%28%5Cn%5Ct'https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2F%40js-joda%2Fcore%401.11.0%2Fdist%2Fjs-joda.js'%5Cn%29%5Cnconst%20pattern%20%3D%20JSJoda.DateTimeFormatter.ofPattern%28'dd.MM.yyyy'%29%5Cnconst%20iJSJoda%20%3D%20JSJoda.ZonedDateTime.parse%28%20iso%20%29%22%5D)

  

Причина, по всей видимости, в том, что создание объектов в Firefox происходит не очень быстро, а в JSJoda упоролись по паттернам. Так бывает, когда оптимизируешь библиотеку лишь под один движок, и совсем забиваешь на альтернативные. Вместо хорошей производительности везде, получается, что на одном движке всё летает, а на другом еле ползает.

  

# Как это работает

  

Интерфейс моей пипиркомерки состоит из следующих блоков:

  

* общий код
* вариативный код
* результаты

  

[![](https://habrastorage.org/r/w1560/getpro/habr/post_images/359/950/463/35995046312bf5eaa9502f3c10e98ecf.png)](https://perf.js.hyoo.ru/#prefixes=%5B%22%2F%2F%20setup%201%22%2C%22%2F%2F%20setup%202%22%5D/sources=%5B%22%2F%2F%20action%201%22%2C%22%2F%2F%20action%202%22%5D)

  

## Общий код

  

Располагается слева. Он разделён на часть, которая исполняется до замера, и часть, которая уже после. Первая подходит для общей предварительной инициализации. А вторая — для тестов, ведь важно убедиться, что измеряли время работы мы именно того поведения, что хотели.

  

Время работы общего кода в результаты, конечно же не входит.

  

Для инициализации и тестов порой важно знать сколько итераций будет прогоняться измеряемый вариант. Для получения этого числа доступен специальный макрос `{#}`.

  

Например, мы хотим, чтобы для каждой итерации у нас был уникальный объект, но не хотим, чтобы его создание влияло на замеры. Тогда мы можем заранее создать массив из нужного числа объектов:

  

```javascript
const list = Array.from(
    { length: {#} },
    (_,i)=> new Date( `2015-07-20T07:48:28.${ i % 1000 }Z` ),
})
```

  

## Вариативный код

  

Располагается посередине. Каждый вариант состоит из двух частей:

  

* **Подготовительная**, которая исполняется один раз и не замеряется.
* **Замеряемая**, которая исполняется множество раз.

  

В замеряемом коде так же доступен макрос `{#}`, но тут он означает уже не число итераций, а номер текущей итерации. Например, мы можем взять из ранее объявленного массива уникальный объект и что-то с ним сделать:

  

```plaintext
res = list[{#}].toString()
```

  

## Результаты

  

Появляется справа после запуска тестов и исчезает при изменении кода. Для каждого варианта выводит два результата:

  

* **Прохладный**, когда замеряемый код копипастится много раз и эта портянка исполняется лишь один раз, а значит движок применит лишь базовые оптимизации.
* **Разгорячённый**, когда замеряемый код выносится в функцию и копипастится уже её вызов. Таким образом замеряемый код исполняется множество раз, что позволяет движку применить расширенные оптимизации.

  

Код разгорячённой функции измерения получается примерно таким:

  

```javascript
function measure() {

    // common setup code

    // case setup code

    let accum_$qwerty
    const case_$qwerty = iter_$qwerty => {
        // measured code where {#} replaced by iter_$qwerty
        accum_$qwerty = iter_$qwerty
    }
    let time_$qwerty = -performance.now()

    case_$qwerty(0);
    case_$qwerty(1);
    case_$qwerty(2);

    // ...

    time_$qwerty += performance.now()
    // teardown code
    return time_$qwerty
)
```

  

А код прохладной чутка другим:

  

```javascript
function measure() {

    // common setup code

    // case setup code

    let accum_$qwerty
    const case_$qwerty = iter_$qwerty => {
        accum_$qwerty = iter_$qwerty
    }
    let time_$qwerty = -performance.now()

    case_$qwerty(0);
    // measured code where {#} replaced by 0
    case_$qwerty(1);
    // measured code where {#} replaced by 1
    case_$qwerty(2);
    // measured code where {#} replaced by 2

    // ...

    time_$qwerty += performance.now()
    // teardown code
    return time_$qwerty
)
```

  

Как видно, они практически не отличаются по выполняемой работе. Однако, важно отметить, что в замер попадает не только замеряемый код, но и один вызов функции. Это даёт дополнительно примерно 20 наносекунд. Стоит учитывать это при замере экстремально быстрого кода.

  

# Подключение библиотек

  

Если нужно подключить какую-либо библиотеку, то можно воспользоваться модулем [$mol\_import](https://github.com/hyoo-ru/mam_mol/tree/master/import), чтобы загрузить её из CDN:

  

```javascript
const {
    $mol_time_moment: Moment,
    $mol_time_interval: Interval,
    $mol_time_duration: Duration,
} = $mol_import.script('https://unpkg.com/mol_time_all@1.1.12/web.js')
```

  

# Тесты

  

Для тестов можно воспользоваться функциями [$mol\_assert](https://github.com/hyoo-ru/mam_mol/tree/master/assert):

  

```javascript
$mol_assert_like( [ 1 ], [ 1 ], [ 2 ] ) // Not like [1] --- [2]
```

  

# Послесловие

  

[perf.js.hyoo.ru](https://perf.js.hyoo.ru/) — собственно, мой инструмент для нанобенчмаркинга. Примеряйте его к своему коду, не стесняйтесь. Выкладывайте скриншоты с интересными сравнениями — обсудим почему всё именно так.

  

[bench.hyoo.ru](https://github.com/hyoo-ru/bench.hyoo.ru) — ещё один инструмент, но уже не для нанобенчмаркинга кода, а для бенчмаркинга целых приложений. Я рассказывал о нём в статье: [bench.hyoo.ru: готовим JS бенчмарки быстро и просто](https://mol.hyoo.ru/#section=articles/search/author=nin-jin/repo=HabHub/article=8).

  

А если вы мейнтейнер какой-либо JS библиотеки, то пишите в личку, если хотите присоединиться к нашему полузакрытому чату, где мы в кругу мейнтейнеров обсуждаем всякие такие, не интересные обычным разработчикам, темы.

  

![](https://habrastorage.org/r/w1560/getpro/habr/post_images/02c/7a2/b4a/02c7a2b4a5602d64fff8a3b8238c3f66.png)

Только зарегистрированные пользователи могут участвовать в опросе. [Войдите](/kek/v1/auth/habrahabr/?back=/ru/articles/543934/&hl=ru), пожалуйста.

Какая у вас длина?

5.88% > 50 Начисление одного приглашения (однократно), позволяющего сделать полноправным аккаунт любого пользователя, кроме заблокированного за нарушение правил сообщества2

8.82% ≥ 30 Размещать публикации в хабе «Я пиарюсь»3

14.71% ≥ 5 Голосовать за публикации, комментарии и карму других пользователей5

23.53% ≥ 1 Отключать показ рекламных блоков8

23.53% ≥ 0 Размещать публикации в профильные хабы8

14.71% От −1 до −10 Возможность размещать комментарии лишь 1 раз в 5 минут5

0% От −11 до −30 1 комментарий в час0

2.94% От −31 до −100 1 комментарий в день1

5.88% От −100 и ниже 1 комментарий в неделю и значок «Тролль»2

Проголосовали 34 пользователя. Воздержались 23 пользователя.