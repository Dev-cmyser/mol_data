# s
Здравствуйте, меня зовут Дмитрий Карловский и я.. автор [множества](https://mol.hyoo.ru/#!section=docs/=uybppd_9xory7) микроскопических и самых шустрых в своём классе библиотек. Одна из них — `$mol_compare_deep`, умеющая сравнивать произвольные структуры, даже содержащие циклические ссылки. И сейчас я вам расскажу, как ей это удаётся.

Cперва, небольшая предыстория, почему эта библиотека вообще нам понадобилась для реализации реактивной системы.

## Эквивалентные изменения

Порой значение меняется на эквивалентное. И тут есть разные подходы к отсечению вырожденных вычислений.

* ?Every: Реакция на каждое действие
* ?Identity: Сравнение по ссылке
* ?Equality: Структурное сравнение
* ?Reconcile: Структурная сверка

## Dupes: ?Every

В библиотеках типа RxJS каждое значение является уникальным событием, что приводит к ненужному запуску реакций.

```typescript
777 != 777


```

Чтобы этого не происходило, нужно писать дополнительный код, который часто забывают, и потом огребают.

## Dupes: ?Identity

Многие библиотеки всё же умеют сравнивать значения. И если состояние не поменялось, то реакции не срабатывают. А если поменялось, даже на эквивалентное значение, то срабатывают.

```typescript
        777 == 777

[ 1, 2, 3 ] != [ 1, 2, 3 ]


```

Если мы нафильтровали новый массив, с тем же содержимым, то скорее всего нам не нужно запускать каскад вычислений. Но вручную уследить за всеми такими местами - мало реалистично.

## Dupes: ?Equality

Наиболее продвинутые библиотеки, типа $mol\_wire, делают глубокое сравнение нового и старого значения. В некоторых других, типа CellX, его можно включить в настройках.

```typescript
        777 == 777

[ 1, 2, 3 ] == [ 1, 2, 3 ]

[ 1, 2, 3 ] != [ 3, 2, 1 ]


```

Это позволяет отсекать лишние вычисления как можно раньше — в момент внесения изменений. А не в момент рендеринга заново сгенерированного VDOM в реальный DOM, как это часто происходит в React, чтобы узнать, что в доме‑то менять и нечего.

Глубокое сравнение — это, безусловно, сама по себе более дорогая операция, чем просто сравнение двух ссылок. Однако, рано или поздно, сравнить всё содержимое всё равно придётся. Но гораздо быстрее это сделать пока данные рядом, а не когда они разлетятся по тысяче компонент в процессе рендеринга.

Тем не менее, если данные поменялись, то полетят дальше по приложению и будут глубоко сравниваться снова и снова, что никуда не годится. Поэтому тут важно реализовывать кеширование результата глубокого сравнения для каждой пары сравниваемых объектов.

## Dupes: ?Reconcile

Наконец, можно пойти ещё дальше, и не просто глубоко сравнивать значения, но и делать их сверку, чтобы сохранить ссылки на старые объекты, когда они эквивалентны новым.

```typescript
const A = { foo: 1, bar: [] }
const B = { foo: 2, bar: [] }

reconcile( A, B )

assert( B.foo === 2 )
assert( B.bar === A.bar )


```

Как видите, `A` и `B` у нас тут отличаются, но свойство `bar` осталось таким как было. Это хорошо с точки зрения GC, ведь мы переиспользуем объекты, находящиеся в старом поколении сборщика мусора. А объект из молодого поколения при сверке был выборошен, что очень быстро.

Кроме того, когда в дальнейшем в компоненте, что рендерит `bar`, будет снова произведена его сверка, то произойдёт это крайне быстро, ведь старое и новое значения будут идентичны. С другой стороны, если объекты всё же будут отличаться, то повторная сверка снова пойдёт по всем внутренностям объекта. Тут опять же необходимо кеширование. Но..

Изменение полей нового объекта на значения из старого — это не всегда безопасная операция. Например, с DOM‑элементами такие финты проворачивать нельзя. В лучшем случае это не заработает, а в худшем вообще его сломает. В ряде случаев вы будете получать исключение при попытке изменить объект. Порой изменения будут попросту игнорироваться, а порой запускать сеттеры, делающие какие‑нибудь стрёмные дела.

К тому же, если объекты фактически идентичны, нам надо сначала их глубоко сравнить. И если они одинаковы, то вернуть старый, а если нет — начать менять новый. Ну либо сразу начать менять новый, чтобы потом выяснить, что мы поменяли все его свойства, так что вернуть надо старый.

Короче, данный подход не самый шустрый и надёжный, поэтому в $mol мы от него отказались в пользу глубокого сравнения с кешированием.

---

Когда реактивное состояние принимает новое значение, мы должны уведомить подписчиков об изменении. Но если изменение даёт эквивалентный результат, то можно ничего и не делать. Нам надо лишь понять: является ли изменение эквивалентным, или нет.

Например, если мы получили новый массив, но он поэлементно равен предыдущему, то даже если мы пересчитаем всё, зависящее от него, приложение, то для пользователя ничего не поменяется.

Получается нам надо уметь глубоко сравнивать новые данные и старые. Причём делать это быстро. Но тут на нашем пути может возникнуть ряд трудностей..

Некоторые объекты (например, [Value Object](https://en.wikipedia.org/wiki/Value_object)) можно сравнивать структурно, другие же (например, DOM элементы или бизнес-сущности) - нельзя. Как их отличать?

Ну, стандартные типы (массивы, структуры, регулярки и тп) можно просто детектировать и сравнивать структурно.

С пользовательскими же чуть сложнее. По умолчанию не будем рисковать, а будем сравнивать их по ссылке. Но **если в объекте объявлен метод** `Symbol.toPrimitive`, то считаем, что это сериализуемый объект, а значит такие объекты можно сравнивать через сравнение их сериализованных представлений.

```typescript
class Moment {
	
	iso8601: string
	timestamp: number
	native: Date
	
	[ Symbol.toPrimitive ]( mode: 'number' | 'string' | 'default' ) {
		switch( mode ) {
			case 'number': return this.timestamp
			case 'string': return this.iso8601
			case 'default': return this.iso8601
		}
	}
	
}


```

Если мы сравнили глубокие структуры и выяснили, что они в целом отличаются, то, когда будем их поддеревья передавать дальше, было бы опрометчиво сравнивать их снова и снова, ведь мы это уже сделали ранее. Поэтому результат глубокого сравнения пар объектов мы будем кешировать в двойных WeakMap, что обеспечит нам автоматическую очистку кеша по мере сборки объектов сборщиком мусора.

![](https://habrastorage.org/r/w1560/webt/_p/q6/yd/_pq6ydh7ajlgkp0rbpmg22xsgm0.png)

После сравнения, один из объектов Left и Right обычно выкидывается. В первом случае это освободит и кеш целиком, и все его данные, а значит при изменении значения, у нас ничего лишнего в памяти не останется. Во втором же случае освободятся только данные, а сам кеш останется для будущих сравнений, что предотвращает лишнюю аллокацию кешей при частом прилёте эквивалентных значений.

Наконец, в данных могут встретится циклические ссылки. Как минимум тут нельзя уходить в бесконечный цикл. А желательно правильно их сравнивать.

Например, следующие два объекта структурно эквивалентны:

```typescript
const left = { id: 'leaf', kids: [] }
left.kids.push({ id: 'son', parent: left })

const right = { id: 'leaf', kids: [] }
right.kids.push({ id: 'son', parent: right })


```

Оказывается, поддержать циклические ссылки совсем не сложно, когда у нас уже есть кеш. Сперва пишем в него, что объекты эквивалентны, и погружаемся в глубь. Если снова наткнёмся на эту пару объектов, то возьмём значение из кеша и пойдём дальше. Если же где-то найдём отличия, то и в кеше потом поправим, что объекты всё-таки не эквивалентны.

В результате, у нас получилась библиотека [$mol\_compare\_deep](https://github.com/hyoo-ru/mam_mol/tree/master/compare/deep), размером в 1 килобайт, которая  [быстрее](https://mol.hyoo.ru/#!section=bench/bench=equals) любых других, представленных в NPM:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d83/f54/e68/d83f54e681ba8b2a62699a4aa09e3d8a.png)

Поиграться с ней можно в [нашей JS-песочнице](https://eval.js.hyoo.ru/#!code=const%20compare%20%3D%20%24mol_import.module%28%0A%09'https%3A%2F%2Fesm.sh%2Fmol_compare_deep'%0A%29.default.%24mol_compare_deep%0A%0Aconst%20el%20%3D%20document.createElement%28%20'div'%20%29%0Aconst%20make%20%3D%20i%20%3D%3E%20%7B%0A%0A%09const%20next%20%3D%20%7B%0A%09%09obj%3A%20%7B%0A%09%09%09x%3A%20new%20Map%28%5B%5B%20el%2C%20%2F3%2F%20%5D%5D%29%2C%0A%09%09%09y%3A%20new%20Set%28%5B%20new%20Date%281%29%20%5D%29%2C%0A%09%09%7D%2C%0A%09%09val%3A%20%5B%20true%2C%201%2C%20'2'%2C%20i%20%5D%2C%0A%09%7D%0A%0A%09next.val.push%28%20next%2C%20next.obj%2C%20next.val%20%29%0A%0A%09return%20next%0A%7D%0A%0Aconst%20equal%20%3D%20compare%28%20make%281%29%2C%20make%281%29%20%29%0Aconst%20unique%20%3D%20compare%28%20make%281%29%2C%20make%282%29%20%29/run=true) или сразу в своём проекте. Баги и респекты присылайте в [тему про $mol](https://t.me/h_y_o_o/2) на форуме Гипер Дев.

---

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/dfb/6c7/10b/dfb6c710bd2d39fcc248180287c38bbd.png)

[Актуальный оригинал на $hyoo\_page](https://page.hyoo.ru/#!=t1wfzq_wm00cv)

Только зарегистрированные пользователи могут участвовать в опросе. [Войдите](/kek/v1/auth/habrahabr/?back=/ru/articles/724098/&hl=ru), пожалуйста.

Как вы сравниваете значения?

23.68% По ссылке9

18.42% Поверхсностно7

34.21% Глубоко13

7.89% Реконцилирую3

44.74% Без понятия17

Проголосовали 38 пользователей. Воздержались 15 пользователей.