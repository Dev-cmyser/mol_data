# s
Здравствуйте, меня зовут Дмитрий Карловский и (сколько себя помню) я борюсь со своим окружением. Ведь оно такое костное, дубовое, и никогда не понимает, что я от него хочу. Но в какой-то момент я понял, что хватит это терпеть и надо что-то менять. Поэтому теперь не окружение диктует мне, что я могу и не могу делать, а я диктую окружению каким ему быть.

Как вы уже поняли, далее речь пойдёт про инверсию контроля через "контекст окружения". Многим этот подход уже знаком по "переменным окружения" - они задаются при запуске программы и обычно наследуются для всех программ, которые та запускает. Мы же применим эту концепцию для организации нашего кода на TypeScript.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5eb/032/f5b/5eb032f5b736749a4e50dabbafd4ddd2.png)

Итак, что мы хотим получить:

* Функции при вызове наследуют контекст у вызвавшей их функции
* Объекты наследуют контекст у их объекта-владельца
* В системе может существовать одновременно множество вариантов контекста
* Изменения в производных контекстах не влияют на исходный
* Изменения в исходном контексте отражаются на производных
* Тесты могут запускаться в изолированном и не изолированном контексте
* Минимум бойлерплейта
* Максимум перфоманса
* Тайпчек всего этого

Давайте, объявим какую-нибудь глобальную константу в глобальном контексте окружения:

```cs
namespace $ {
    export let $user_name: string = 'Anonymous'
}

```

Теперь добавим в глобальный контекст какую-нибудь функцию. Например, функцию записи в лог:

```cs
namespace $ {
    export function $log( this: $, ... params: unknown[] ) {
        console.log( ... params )
    }
}

```

Обратите внимание на типизированный `this`. Он гарантирует, что данную функцию нельзя будет вызвать напрямую так:

```cs
$log( 123 ) // Error

```

Вызвать её можно исключительно из какого-либо контекста окружения. Например, из глобального контекста:

```cs
$.$log( 123 ) // OK

```

Однако, пока что `$` у нас - это неймспейс, а не тип. Давайте для простоты создадим и одноимённый тип:

```cs
namespace $ {
    export type $ = typeof $
}

```

А раз мы получаем контекст окружения в `this`, то можем его использовать и для вызова других функций. Например, напишем функцию, которая приветствует пользователя по имени:

```cs
namespace $ {
    export function $hello( this: $ ) {
        this.$log( 'Hello ' + this.$user_name )
    }
}

```

Таким образом мы естественным образом можем передавать контекст окружения по стеку вызовов функций на любую глубину. Но в этом мало смысла, пока контекст всего один. Поэтому добавим фабрику контекстов, которая берёт текущий контекст, наследует от него производный, патчит его переданными ей переопределениями и возвращает:

```cs
namespace $ {
    export function $ambient(
        this: $,
        over = {} as Partial< $ >,
    ): $ {
        const context = Object.create( this )
        for( const field of Object.getOwnPropertyNames( over ) ) {
            const descr = Object.getOwnPropertyDescriptor( over, field )!
            Object.defineProperty( context, field, descr )
        }
        return context
    }
}

```

`Object.create` мы используем, чтобы создание производного контекста было быстрым, даже если он разрастётся. А вот `Object.assign` не используется, чтобы в переопределениях можно было задавать не только значения, но и геттеры, и сеттеры. Эта фабрика нам ещё пригодится, а пока давайте напишем наш первый тест:

```cs
namespace $.test {
    export function $hello_greets_anon_by_default( this: $ ) {

        const logs = [] as unknown[]
        this.$log = logs.push.bind( logs )

        this.$hello()
        this.$assert( logs, [ 'Hello Anonymous' ] )

    }
}

```

Тест принимает на вход контекст кружения, и первым делом он настраивает контекст под себя - патчит функцию `$log`, чтобы та сохраняла все логи в локальную переменную. Потом мы запускаем тестируемую функцию в нашем контексте, и наконец, проверяем, что в логи вывелось именно то, что мы ожидаем. Напишем простейшую функцию для асертов:

```cs
namespace $ {
    export function $assert< Value >( a: Value, b: Value ) {

        const sa = JSON.stringify( a, null, '\t' )
        const sb = JSON.stringify( b, null, '\t' )

        if( sa === sb ) return
        throw new Error( `Not equal\n${sa}\n${sb}`)

    }
}

```

Обратите внимание, что мы поместили тест в отдельный неймспейс `$.$test`. Это нужно для того, чтобы взять и запустить все тесты скопом:

```cs
namespace $ {
    export async function $test_run( this: $ ) {

        for( const test of Object.values( this.$test ) ) {
            await test.call( this.$isolated() )
        }

        this.$log( 'All tests passed' )
    }
}

```

Каждый тест запускается не в оригинальном контексте, а в изолированном. Это такой производный контекст, где замоканы все сущности, что общаются со внешним миром (сетевые запросы, время, консоль, файлы, рандом и т.д.). Исходно, она просто создаёт новый производный контекст:

```cs
namespace $ {
    export function $isolated( this: $ ) {
        return this.$ambient({})
    }
}

```

Но наша функция `$log` пишет в реальную консоль, что не очень-то похоже на изоляцию. Поэтому, рядом с ней мы положим переопределение `$isolated`, которое переопределяет в контексте `$log` на реализацию без сайд эффектов:

```cs
namespace $ {
    const base = $isolated
    $.$isolated = function( this: $ ) {
        return base.call( this ).$ambient({
            $log: ()=> {}
        })
    }
}

```

Теперь мы уверены, что любые тесты по умолчанию не будут ничего писать в реальную консоль даже если мы не переопределим в них функцию `$log`.

Давайте так же напишем и тест, что наши переопределения контекстов работают исправно:

```cs
namespace $.test {
    export function $hello_greets_overrided_name( this: $ ) {

        const logs = [] as unknown[]
        this.$log = logs.push.bind( logs )

        const context = this.$ambient({ $user_name: 'Jin' })
        context.$hello()
        this.$hello()

        this.$assert( logs, [ 'Hello Jin', 'Hello Anonymous' ] )

    }
}

```

Теперь перейдём к объектам. Для простоты работы с контекстами введём простой базовый класс для всех наших классов:

```cs
namespace $ {
    export class $thing {
        constructor( private _$: $ ) {}
        get $() { return this._$ }
    }
}

```

Тут мы инъектируем контекст окружения через конструктор. И добавляем геттер, позволяющий получать зависимости через контекст минимальным объёмом кода. Геттер нам нужен для того, чтобы можно было переопределять контекст в потомках не потеряв переопределения предков. Для примера, создадим карточку, которая приветствует пользователя, добавляя к имени восклицательный знак:

```cs
namespace $ {
    export class $hello_card extends $thing {

        get $() {
            return super.$.$ambient({
                $user_name: super.$.$user_name + '!'
            })
        }

        get user_name() {
            return this.$.$user_name
        }
        set user_name( next: string ) {
            this.$.$user_name = next
        }

        run() {
            this.$.$hello()
        }

    }
}

```

Напишем тест, чтобы удостовериться, что это действительно работает:

```cs
namespace $.test {
    export function $hello_card_greets_anon_with_suffix( this: $ ) {

        const logs = [] as unknown[]
        this.$log = logs.push.bind( logs )

        const card = new $hello_card( this )
        card.run()

        this.$assert( logs, [ 'Hello Anonymous!' ] )

    }
}

```

Супер, теперь посмотрим, как выстраивать дерево объектов. Тут основная идея в том, что у каждого объекта есть владелец, который контролирует его время жизни и контекст окружения. Давайте создадим страничку, которая владеет нашей карточкой:

```cs
namespace $ {
    export class $hello_page extends $thing {

        get $() {
            return super.$.$ambient({
                $user_name: 'Jin'
            })
        }

        @ $mem
        get Card() {
            return new this.$.$hello_card( this.$ )
        }

        get user_name() {
            return this.Card.user_name
        }
        set user_name( next: string ) {
            this.Card.user_name = next
        }

        run() {
            this.Card.run()
        }

    }
}

```

Выносим создание владеимого объекта в отдельное свойство. Инъектим в него текущий контекст. И мемоизируем результат с помощью `$mem`. Возьмём самую простую его реализацию без реактивности:

```cs
namespace $ {
    export function $mem(
        host: object,
        field: string,
        descr: PropertyDescriptor,
    ) {
        const store = new WeakMap< object, any >()

        return {
            ... descr,
            get() {

                let val = store.get( this )
                if( val !== undefined ) return val

                val = descr.get!.call( this )
                store.set( this, val )

                return val
            }
        }

    }
}

```

`WeakMap` нужен чтобы такое свойство можно было безопасно переопределять в подклассах, не ломая мемоизацию. Что ж, проверим, что имя пользователя действительно поменялось, а восклицательный знак не потерялся:

```cs
namespace $.test {
    export function $hello_page_greets_overrided_name_with_suffix( this: $ ) {

        const logs = [] as unknown[]
        this.$log = logs.push.bind( logs )

        const page = new $hello_page( this )
        page.run()

        this.$assert( logs, [ 'Hello Jin!' ] )

    }
}

```

Отлично, работает. Теперь усложняем задачу - переопределяем класс для поддерева объектов. Создадим новый класс для карточки, который позволяет переопределять имя пользователя, сохраняя его в локальное хранилище.

```cs
namespace $ {
    export class $app_card extends $.$hello_card {

        get $() {
            const form = this
            return super.$.$ambient({
                get $user_name() { return form.user_name },
                set $user_name( next: string ) { form.user_name = next }
            })
        }

        get user_name() {
            return super.$.$storage_local.getItem( 'user_name' ) ?? super.$.$user_name
        }
        set user_name( next: string ) {
            super.$.$storage_local.setItem( 'user_name', next )
        }

    }
}

```

Само локальное хранилище - это просто алиас для нативного объекта:

```cs
namespace $ {
    export const $storage_local: Storage = window.localStorage
}

```

А раз оно у нас персистится, то нужно нужно рядом положить и мок, который сохраняет данные не в нативное хранилище, а во временный объект:

```cs
namespace $ {
    const base = $isolated
    $.$isolated = function( this: $ ) {

        const state = new Map< string, string >()
        return base.call( this ).$ambient({

            $storage_local: {
                getItem( key: string ){ return state.get( key ) ?? null },
                setItem( key: string, val: string ) { state.set( key, val ) },
                removeItem( key: string ) { state.delete( key ) },
                key( index: number ) { return [ ... state.keys() ][ index ] ?? null },
                get length() { return state.size },
                clear() { state.clear() },
            }

        })

    }
}

```

Теперь мы, наконец, можем реализовать наше приложение, которое подменяет в контексте исходный класс `$hello_card` на свой `$app_card`, и всё поддерево объектов будет инстанцировать именно его.

```cs
namespace $ {
    export class $app extends $thing {

        get $() {
            return super.$.$ambient({
                $hello_card: $app_card,
            })
        }

        @ $mem
        get Hello() {
            return new this.$.$hello_page( this.$ )
        }

        get user_name() {
            return this.Hello.user_name
        }

        rename() {
            this.Hello.user_name = 'John'
        }

    }
}

```

Напишем пользовательский сценарий, где мы сначала сохраняем состояние локального хранилища и стираем его, потом проверяем, что имя соответствует дефолтному поведению, при переименовывании оно меняется и сохраняется даже при перезапуске приложения, а в конце подчищаем за собой, убеждаемся, что очистка сработала, и восстанавливаем состояние локального хранилища:

```cs
namespace $.$test {
    export function $changable_user_name_in_object_tree( this: $ ) {

        const name_old = this.$storage_local.getItem( 'user_name' )
        this.$storage_local.removeItem( 'user_name' )

        const app1 = new $app( this )
        this.$assert( app1.user_name, 'Jin!' )

        app1.rename()
        this.$assert( app1.user_name, 'John' )

        const app2 = new $app( this )
        this.$assert( app2.user_name, 'John' )

        this.$storage_local.removeItem( 'user_name' )
        this.$assert( app2.user_name, 'Jin!' )

        if( name_old !== null ) {
            this.$storage_local.setItem( 'user_name', name_old )
        }

    }
}

```

Тесты неспроста написаны в таком стиле, чтобы их можно было запускать не только на чистом состоянии, но и на грязном. Это позволит нам гонять одни и те же тесты с разными уровнями изоляции.

Запустим тесты в полностью изолированном контексте, чтобы проверить, что реализовали всю нашу логику правильно:

```cs
namespace $ {
    $.$test_run()
}

```

А теперь запустим их же, но без изоляции, чтобы проверить, что наша логика корректно работает со внешними системами. Для этого просто создадим контекст, где `$isolated` возвращает производный контекст, но без каких-либо переопределений:

```cs
namespace $ {
    $.$ambient({
        $isolated: $.$ambient
    }).$test_run()
}

```

Этот второй вариант, если запустить в Сафари в порно режиме, выдаст исключение, так как в нём нельзя обращаться к localStorage, а этот кейс в нашей наивной реализации `$storage_local` не предусмотрен.

Аналогично, запуская тесты в разных контекстах, можно проверять работу вашего кода с публичным сервером, с тестовым сервером, и вообще без сервера.

Подробнее об этом подходе к тестированию можно ознакомиться в моём выступлении на TechLeadConf: [Фрактальное Тестирование](https://slides.hyoo.ru/#slides=https%3A%2F%2Fnin-jin.github.io%2Fslides%2Ftesting%2F).

Разобранный же тут подход к инверсии контроля активно применяется во [фреймворке $mol](https://mol.hyoo.ru/), что даёт ему потрясающую гибкость и простоту кода. Но это уже совсем другая история…

Если вас смущает общий неймспейс и отcутствие import/export, то можете ознакомиться с этим анализом: [Fully Qualified Names vs Imports](https://github.com/hyoo-ru/mam_mol/wiki/Fully-Qualified-Names-vs-Imports). А если смущает именование через подчёркивание, то с этим: [PascalCase vs camelCase vs kebab case vs snake\_case](https://github.com/hyoo-ru/mam_mol/wiki/PascalCase-vs-camelCase-vs-kebab-case-vs-snake_case).

[TypeScript песочница со всем кодом из статьи.](https://www.typescriptlang.org/play?emitDecoratorMetadata=false&ssl=84&ssc=9&pln=84&pc=35#code/PQKhAIHEBsHsCMCG1yILbwJYFMB2AXcAY1gOwA9CRgAoXdbAZwAdEjtwAScAbxvAHhQEGAmTFSjfIgLhq-QRWawAToWjZCnAK6NsKgPr002AFzgpKzLgDm4ALzgA5AEFcpAJ5pYupzQC+NHQMLGwc3HyCQmDgLhg4siRklOD4Hswc8lFKqoRpGVwOqenYsABmXAFBxkys7IWRgsLgAAoqsAAm2uyM4B36mABu2B3gmIyw0Ij4I6jxeIRJMylZiuTKauBl2rhE+JikXOOT0yMAFKkAFuPm3ACUvApRAiqa2iq4V+MAdJzoWAszjx-HcnuBAoFgiZQvUImDmqIkChtrt9odVgIcpsUXsDp9OHAbBd8NdGLcADTgb7U8CsFToMngHYAa3cAHdcABtAC64AejWeElwEw030JF2p31piHpaF6oKiEKhtTCDXhMQAkiLTqNhipGHjwOVwDY4EitjtcejaFEklJwEg9EVOMcpjMOmDOL9XTqiji0bhiaTbnzHoKXm8Pg7EHpvkRkNAg+M+b9-gl8ECweGuITzGc7vYAHy8QLZkFgpXKmHhMNNGKI8T+w0k6ZMvS9QbIbRMLbtNBzAGJUjLKg2tYbQhNw6cS7YaBwJOM+61wUkn4E2BE5wACTncGc4AA1F9GL9dPojAw+RWqlW6jWBdEIAAlHa9awD9NCkeoed9bBEFMryjDMUi9Bi4BYoQMYeLsFqooanCgfgBgqDsi4hvyWaCNhAhlKoFx2nkTCEMaADy8AAFYAfg3ydtA3aMIuvzIaGWHZlEiBsogmDEVIcYJsxLrau6+bXmWQTZmup4blurh-shvSsIwegdE44mCJWNTVmqUTNAAypgaDMBoqAqfoAbwVanwQVBVmWX85lqAAPOAABqXYcIWFyIOYHkMdglLwH5nmho+US4UK9qMIgRQAFL6WRABy3yWNYNiYGUHg+ZSuDaPOlJOAAOvg6kKuGREWPA8WJSlaW2Jl2UOrl+XQIVJVlZFkWZRcMUOPYjiMNVDyvPg7y4JFJLtGy4C4NgM0AKIqO0KgXAABklsCENgACO2jIEVuCcDwMX+Idx1Df4a2gjekLafeXAsSRK5PuAAAqJG9Aa-SoGUZQ0XIY6YusuT2Yhs7zrABg2K8miMAYMikAY8AeAY-RlIg+UZiemGPJFlWEr0jg8mZTK4KysAcjyk2kr8hJFIT3zMLolzfFguAdBchMaYKNPrhDC7lautOOXoahc5ujCUpyO57rAsTuLgXg+Iw6m8jdiq3vdqpwnpMRtJ03Q9v0VjDKMaYLN+FCEGyvGXEaepWP04FA5BIPYpaDkWwQZx80u5KRbAepFMCpMtDK+zIK53CFgHUR3CG4WCJVSzW0UFHUXscavKci4888+GrVFk44NAozkVRNHfDYmhkRyBsZGoHhJSEFxB-obEvdmlXO0QKjp5XWc1-gde4A3FkeAAIkwfeYMw+AEQ7+iUmUpejHcACEkVRBnVfo9Y2Dj03hHDtbK9r5Svf90LzyluGo3jVblC3dUIQPV6SHPY+zQfWBn6W6nFI7dlqYGdoDMEdkpz4gFlDGG2A4YGGAU7EYl4TAYUKFhfGkh1CSyKCTGMZMKZU25H7Omm4GaSyZizNm1hObgG5jfCK3dsFP0II4aSqZ5g+x4Fwc8hgajmCcHFaw6lyzMOSLRGcct8ykKkZDGR2ZZExjFtjQm0tZaQ3AMI3AThCq7k0W4Tw3hfDgHVpJTSWs346xes0AAQjGDggFlHgFtiSf+Q4JEWG0MwCc4Dsju0WFMFSXA1y2C7snbBaE9iL2YKbU44ADCcFxsCSKw8uBiR4Q-KMHDEnghfneax38YgAGEgm9FcfbJBoDZje0WKfFYrs7JOOCXIuABh4wqFGNbPAHRehIWuGEvgqTNDpPYhxCMY0oyMG8foX4nDBwZiTuMnQYtUFmC8Y3OZKyLw1CPM4DefhxkCDEeGSE2Y0l8LWRk7eggsmfA4R-S5NRIp30FHoQgTyGAXDmpQcw9U7BjPGQ8s8qzdmOB+fgF5XVsxoUDICjiwLWmwAUac8xxzLHQnfk9e0RSIC-3wL0WprCl4gLAYXI0g8CV+PHKDKBXAYHtJlB0aGsMCUI0VgYCpBhpl-UwOQdBy4hniPtNzYmvICEsnZFyEhUkRb00cIzZmjBWbszoQw6FFUWEdNGOC+a9K5aMs6XnRhycmXfFhTIpRTlVGS3UU4fR+5DFK2MYwA5pjrz5O1rCGxMQACy2BvCYAAF49jubMei3ZqXA18XSzgJg0C+2zJcWAUhzAIEzvgOO4ZV5zg6H8-AVhbBZsFFfcwR80jT0YLPeeqhi1hSwcKQgUhVAcF1TNAA6tgRAzJfWIGYK5dNNFKQyA8OAbyGt76Rk+Es54kp-xVpUHW85mhrk3MFBoQg9EijNteNXFdJ585HLGGUC4W6N4DTJvvOa69wB3PAPRNdzxH1RC3Y4K+e78AbwEvOY1z7BA7uwKlfd0lKRbpNeMv9EzH4PqPa82+aK8l3Ssd63F4BSnOIqe4upnjYmwFYDYaYzZ5Ykg4NYOa-dB17BdhAgJxAyn6shgYfDHBukcz6aEuwQrwxpM4Nco9d7pmbI-rUzMR6ojbP4QwQR2jDlHJOYKODTDwwAAEuDxuGYQYpTK+NHLvXNGaiKGXaqEoeixijl0fNBV8+FMKp0nm+Fpzp3xPkmChdmd5bYdlfNmtbfNhaAXhOFj8RzHRnNWZMEUCFbnwyRQtTZ8MHCQvmvQuBvJnrkPhGxYQVD+LCVcOwz+aws4rAzF2BwKaPgbD2xIMZUgCxegFvgVGt2MbPbgwNcxll8C2VVP6MymonK7bcu0Ly-lOMMF42FTgmwRNwD4N6JKym0rZHyvoZQpVKraESxm6ZgQDb7TMci3qpFTHEA11-dmZjyW4UIaiA85RFlttSzmxo-c2i3VmPS5iwpCHmgtFyOIFgAFMqYCIHR5xeoDSHGNKaMQKBmnUf8b4hHXA+3MENV0ygPS+m-CM0ywL4ANOjIJ7aFhhd+zsNJI+gTMyVBbJEzOizvDwvYAybeuz5OwteYi-4JdRyPMSauT535FgC3pTClsVQaAueSYi7qlIinTmpbOdxkZLnWfxcFDToTvwd1newAYOA8ZoAfo1DMBNzh1dlXAAAfhtxs2ZjyWfRbeWrln3zfOi-8-Wo9gnHe64XvSGuhvYDG6A-gM3AaLhOCt7lNOyuEMq4EM0MijtqlfVgBFlH5KyMd2mfARrmRGm0ZR38HxbtSu9JCQMzjt3BA8Z0+M7X-u-j5dE2JgQJ3tW3DRxjvnCmE+RVU3GgNROHXIs188PTerDMdf1yZwfTP1eN44nejh4+ZdrKhbFvA1mSeCHX3LTfYLnBxVgJcHR2-NYRSQ99lD6oIAuGgJgBxvR6D7GGBSjNqR5ZEsAaOGjZHFhTgPXYPI3ZAcwfSQPfXIoW2DmSmMUUPZAKA1QfXKoL1B8MESqR0VtI4ESEYB-cAX1UPZkMYYyDQEwAgQjQ4FsQgH0UCCwapSCP6GiRHQQD+eg2YRwKBAVetfbJtaQGYI7GaXtftL3dKSkf5MdFFLXOzHA79RMA9O4eZdMTMR9EA6AsApA6AcwRnVXCPc3C4ZkbADwPzcXO4TJOzKQU4D9Iwkw0MO3WaVqcEfvDid5SPC3Yw0w8Qote9CAnwgLHhawmYcPOwjwUDcQB4XnSDdnbwYYDwsIswsJfkUXGw-oDdVncALw0MaIjvAQLwi4WhCgcwPKDADuFIu9GWOdYIwDLwpiB4bkGWIo8gd1RwvKP8XIvItJDQWwEkNnATQQwDA0ENFwmIwCLtVaFImouMDQGUMSTo8ZJPW+VLL7FUWELLH1PFT6WkfQA0awsrZrSBNracIgS4GQAjeADQAwdXAwawRBSlAwQvXgzBKbWaBgRBMuIoB5UAg3cAk3YeBIy3FnTqWVdcH4kPMPV4OI7AQEmPYEj1V4tHAARmENRx8QuwSxFge3FlQB8SROPwYEKne06kimRPNV3zQVS3u2tR8jxIJJMCJPPx0QRM1UbVxOYAACZUSy9mAMSgsZJsTsY0cOT6TApT8mSSTQSZJwS-jyToTYSrddt7NRZHt2SRT1ciTrA3UJ1BQeo3iTAPjRhz1wVnDJ87sRYZTtDw8FTgTcp3jJh14r8LFb81jMCX1YBQFwAzgYI4J8wixJtwxmhXxPgExUhtiPxODzZ8tiUIJOJuJeJHpP4pBUIUs69k8YhgzfwUBFIXE7YfA6CRJDRYy6wIAAAxHiaAd8T4fSRADGKwMYT4WJIYeJbwH6eAACTGJ0NgHoBreWP4lAoPUjXoQuLADofoGyV2OMniLQFQwEPQzvSM24WcggF5ZQpMlCOLRPO4GRSEIAA)

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/cfc/1a4/977/cfc1a4977e0337b375ad6fa5b4a0e200.png)

Только зарегистрированные пользователи могут участвовать в опросе. [Войдите](/kek/v1/auth/habrahabr/?back=/ru/articles/541800/&hl=ru), пожалуйста.

Ваши впечатления от статьи?

9.09% Неверноятно! Она перевернула моё представление об инверсии контроля!4

38.64% Ну, тоже вариант, можно попробовать…17

2.27% Наше решение ничем не хуже…1

52.27% Что за дичь? Тут всё сделано не по фен-шую! Иди читай паттерны, бестолочь!23

Проголосовали 44 пользователя. Воздержались 44 пользователя.